var a = [];
for(var i = 0; i<10;i++){
  a[i] = function(){
    console.log(i)
  }
}
a[6]()//10
//代码中存在两个变量，数组a和循环变量i，数组中的每个元素都保存一个匿名函数，
//在调用a[6]()时，i已经是循环10次后的变量值10。

var tmp = 123;
if(true){
  console.log(tmp);
  //let tmp;
}
//报错 Cannot access 'tmp' before initialization
//let声明的变量，块级作用域，不能声明到全局去，所以不能先使用再声明。

var arr = [12,34,32,89,4]
console.log(Math.min(...arr));

//请详细说明var，let，const三种声明变量的方式之间的具体差别
/**
 * var: var A = 1;声明的变量为全局变量，可以多次赋值，重新定义，可以声明前使用，可以仅声明不初始化，容易造成全局污染
 * let：let A = 1;声明的变量作用域为块级,可以多次赋值，不能重新定义，只能先声明再使用，可以仅声明不初始化，
 * const：const A = 1;声明的变量作用域为块级,基本数据类型不能改变，引用数据类型仅可以改变值，声明时必须初始化
 */

var t = 10;
var obj = {
  t:20,
  fn(){
    setTimeout ( () => { 
      console.log(this.t)//20
    })
  }
}
obj.fn()
//20 fn()函数调用时this指向的是它的上一层作用域，箭头函数没有this指向。

/**
 * symbol ：用来定义对象的唯一属性名
 */

/**
 * 什么是浅拷贝？什么是深拷贝？
 * 浅拷贝：
 * 复制对象的引用，不复制对象本身，当其中一个对象更改时，另一也会改变。
 * 
 * 深拷贝：
 * 复制对象本身。当其中一个对象属性更改时，另一个不会改变。
 * 实现：JSON.parse(JSON.stringify())
 * Object.assign()
 */

/**
 * 简述TS和JS之间的关系:
 * 基于javascript之上的一种编程语言,TypeScript 是 JavaScript 的超集
 */

/**
 * TypeScript的优缺点
 * 缺点：
 *  语言本身多了很多概念
 *  项目初期，TypeScript会增加一些成本
 * 优点
 *  增加代码可维护性
 *  兼容JS语法
 *  减少不必要的类型的判断
 */

/**
 * 引用计数的工作原理和优缺点。
 *  通过一个变量来对引用的变量进行计数，初始值为0，每次引用时增加1，断开引用时减1，当引用计数为0时回收变量。
 * 优点:
    ①发现垃圾时立即回收
    ②最大限度减少程序暂停
  缺点:
    ①无法回收循环引用的对象
    ②时间开销大
 */

/**
 * 简述标记整理算法的工作流程:
 * 首先遍历所有对象，将不可达对象进行标记。
   然后在清除阶段将所有标记为不可达的对象空间进行回收，将所有可达对象进行整理，把可达对象放到连续的内存空间。
 */

/**
 * 描述V8中新生代存储区的垃圾回收流程:
 *    新生代内存区分为两个等大小空间,回收过程采用复制算法+标记整理,使用空间为FROM，
 *    空闲空间为To,活动对象存储于From空间,标记整理后将活动对象拷贝至To,From和To交换空间完成释放。
 *    拷贝过程中可能出现晋升,晋升就是将新生代对象移动至老生代,一轮GC还存活的新生代需要晋升,To空间的使用率超过25%
 */

/**
 * 描述增量标记算法在何时使用及工作原理:
 * 将一整段垃圾回收操作分成几个小段,垃圾回收与程序执行交替完成,程序执行一段时间后，产生垃圾对象，开始遍历对象进行标记，第一次标记可能就标记第一层活动对象，第二次标记所有活动对象，最后对空间进行回收。
 */
const obj2 = {
  foo:function(){
    function bar (){
      console.log(this)
    }
    bar()
  }
}
obj2.foo()