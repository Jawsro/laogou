【简答题】一、谈谈你是如何理解JS异步编程的，EventLoop、消息队列都是做什么的，什么是宏任务，什么是微任务？

答：Javascript将任务的执行模式分为两种，一是同步执行模式，二是异步编程执行模式。JS的执行环境是单线程，即在
同一时间只能做一件事，代码是一次执行。但是如果有接口请求时间响应过长，就会出现假死现象，影响后面的代码执行，
很大程度上降低了执行速度和效率，响应时间过长，用户体验变差。

异步编程：
会使多个任务并发执行，JS在执行异步任务时，不需要等待响应返回， 可以继续执行其他任务，而在响应返回时，会得到
通知，执行回调或事件的处理程序

事件循环（Event Loop）
1、所有同步任都在主线程上执行，形成一个执行栈
2、异步任务会被放置在异步处理模块中，当异步任务有了处理结果，就将该函数移入任务队列。
3、等主线程任务执行完毕后，引擎就会将任务队列的第一项任务放入主线程中执行。
4、重复第三步，主线程从任务队列中读取事件的过程是不断循环的，这整个运行机制就被称为事件循环（Event Loop）。

宏任务和微任务
答：
宏任务：消息队列中的每个任务都是宏任务。
       包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。
微任务：每个宏任务对应都有一个微任务队列。
       包括：Promises, Object.observe, MutationObserver
执行顺序：先执行同步代码，遇到异步宏任务则将异步宏任务放入宏任务队列中，
        遇到异步微任务则将异步微任务放入微任务队列中，
        当所有同步代码执行完毕后，再将异步微任务从队列中调入主线程执行，
        微任务执行完毕后再将异步宏任务从队列中调入主线程执行，一直循环直至所有任务执行完毕。

        同步任务——>微任务——>宏任务
例：
setTimeout(function(){
	console.log('1');
});
new Promise(function(resolve){		    
	console.log('2');
	resolve();
}).then(function(){		    
	console.log('3');
}); 		
console.log('4');

//  2 4 3 1
/*
遇到setTimout，异步宏任务，放入宏任务队列中；
遇到new Promise，new Promise在实例化的过程中所执行的代码都是同步进行的，所以输出2；
而Promise.then中注册的回调才是异步执行的，将其放入微任务队列中
遇到同步任务console.log(‘4’);输出4；主线程中同步任务执行完
从微任务队列中取出任务到主线程中，输出3，微任务队列为空
从宏任务队列中取出任务到主线程中，输出1，宏任务队列为空，结束~
*/